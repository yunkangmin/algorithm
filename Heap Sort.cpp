#include <stdio.h>

int number = 9;
int heap[9] = {7, 6, 5, 8, 3, 5, 9, 1, 6};

int main(void){
	//맨 처음 배열에서 최대힙구조를 만들기. 
	for(int i = 1; i < number; i++){
		int c = i;
		do {
			//특정 원소의 부모 가르키기. 
			int root = (c - 1) / 2;
			//부모값이 자식값보다 작다면 스와핑한다. 
			if(heap[root] < heap[c]){
				int temp = heap[root];
				heap[root] = heap[c];
				heap[c] = temp; 
			} 
			//다시 부모로 가서 반복적으로 수행. 
			c = root;
			
		//루트노드인 0은 부모노드가 없기 때문에 반복문에서 제외됨. 
		} while(c != 0);

		//반복문 수행도.		
		//1. c = 1
		//root = 0
		//if(7 < 6)
		//c = 0
		
		//2. c = 2
		//root = 0
		//if(7 < 5)
		//c = 0
		
		//3. c = 3
		// root = 1
		// if( 6 < 8)
		//7 8 5 6 3 5 9 1 6 
		//c = 1
		
		//4. c = 1
		//root = 0
		//if(7 < 8)
		//8 7 5 6 3 5 9 1 6
		//c = 0
		
		//5. c = 4
		// root = 1
		//if(7 < 3)
		//c = 1
		
		//6. c = 1
		//root = 0
		//if(8 < 7)
		
		//7. c = 5
		// root = 2
		//if(5 < 5)
		//c = 2
		
		//8. c = 2
		//root = 0
		//if(8 < 5)
		//c = 0
		
		//9. c = 6
		//root = 2
		//if(5 < 9)
		//8 7 9 6 3 5 5 1 6 
		//c = 2
		
		//10. c = 2
		//root = 0
		//if(8 < 9)
		//9 7 8 6 3 5 5 1 6
		//c = 0
		
		//11. c = 7
		//root = 3
		//if(6 < 1)
		//c = 3
		//....
		
		//맨 처음에는 1 ~ 8까지 요소를 돈다.
		//인덱스 1요소와 루트노드를 비교한 뒤 1요소가 크면 루트노드와 바꾼다.
		//그다음 2요소와 루트노드를 비교한 뒤 2요소가 크면 루트노드와 바꾼다. 
		//그다음 3요소와 부모노드인 1요소와 비교한 뒤 3요소가 크면 1요소인 부모노드와 바꾼다.
		//그다음 3요소의 부모노드인 1요소와 1요소의 부모노드이자 루트노드를 비교한 뒤 
		//1요소가 더 크면 루트노드와 바꾼다. 
		//그 다음 4요소와 부모노드인 1요소와 비교한 뒤 4요소가 더크면 부모노드인 1요소와 바꾼다.
		
		//즉, 1 ~ 8까지 반복문을 하나씩 돌면서 부모노드와 비교한 뒤 부모노드보다 크면 바꾼다.
		//그다음 부모노드의 부모노드와 비교한 뒤 부모노드가 크면 부모노드의 부모노드와 바꾼다.
		//부모노드의 부모노드가 루트노드이면 반복문을 빠져나오고 다음 인덱스 요소를 탄다. 
	}	
	
	//크기를 줄여가며 반복적으로 힙을 구성
	//루트노드와 가장 뒤에 있는 요소를 바꿔준다. 
	for(int i = number - 1; i >= 0; i--){
		//가장 큰 값을 맨 뒤로 보내기. 
		int temp = heap[0];
		heap[0] = heap[i]; 
		heap[i] = temp;
		
		//다시 힙구조 만들기. 
		int root = 0;
		int c = 1;
		do{
			//자식노드 인덱스 구하기. 
			c = 2 * root + 1;
			//자식 중에 더 큰 값 찾기. 마지막 요소 제외.
			//오른쪽 값이 더 크다면 인덱스를 오른쪽으로 이동. 
			//최하위 - 1은 자식노드가 하나이기 때문에 비교를 안해도 된다. 
			if(heap[c] < heap[c + 1] && c < i - 1){
				c++;
			} 
			
			//루트보다 자식이 더 크다면 교환. 
			//최하위노드가 아닌 경우만. 
			if(heap[root] < heap[c] && c < i){
				int temp = heap[root];
				heap[root] = heap[c]; 
				heap[c] = temp;
			} 
			root = c;
		}while(c < i);
	} 
	//1. 루트노드와 최하위노드를 바꾼다.
	//2. 루트노드와 자식노드 중에 큰 값을 루트노드와 바꾼다.  
	//3. 자식노드의 자식노드들 중 큰 값을 바꾼다. 
	//4. 자식노드의 자식노드들의 자식노드중 큰값을 바꾼다...반복
	//5. 반복은 자식노드가 최하위 노드가 아닐때까지 반복된다. 
	
	for(int i = 0; i < number; i++){
		printf("%d ", heap[i]);
	} 
}


